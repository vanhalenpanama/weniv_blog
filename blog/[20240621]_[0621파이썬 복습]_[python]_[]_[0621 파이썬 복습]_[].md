```
리스트 list 

선언은 대괄호[]


x = [1, 2, 3] #CSV 파일과 비슷 ,
y = ['apple', 'banana', 'cherry']


len(x) 3
len(y) 4

* 길이는 , 로 구분하고 ,,는 인식안되고 ,'',로 공백으로 작성해야된다.

z = [1, 'apple', 2.5, ['a', 'b'], (1, 2)]

len(z) = 5
........................


z[99] # Index Error: list index out of range

리스트는 사실 고정된 크기가 없습니다. 그러나 존재하지 않는것이 수행이 된다면 나중에 문제가 생길수 있습니다. 

.................


문자열은 불변(immutable)입니다. (상수인가)



리스트 덧셈은 두 리스트를 연결합니다.
a = [1, 2, 3, 4, 5]
b = [6, 7, 8]

print(a + b) # 출력: [1, 2, 3, 4, 5, 6, 7, 8]


............................................


곱셈은 리스트를 여러 번 반복합니다.


x = [1]
print(x * 3) # 출력: [1, 1, 1]

x = [1,2]
print(x * 3) # 출력: [1,2, 1,2 1,2]

............................................

'::'는 리스트에서 인덱스를 건너뛰어 요소를 추출할 때 사용됩니다.
::2는 인덱스 간격 2씩 건너뜀
::-1는 거꾸로 출력
..............................................

l = [10, 20, 30]
ll = l[:]
print(id(ll), id(l))

슬라이싱으로 얕은 카피를 피할수 있다.


import copy

k = [10000]

a = [10, k]
b = [100, k]

l = [a, b]
ll = copy.deepcopy(l)

copy 임포트 후 deepcopy로 깊은 카피를 할 수 있다.

...........................

count() 특정 값이 리스트에 몇 번 포함되는지 카운트합니다.

............................
extend() 리스트에 다른 리스트나 순회 가능한(iterable) 항목들을 추가하며 문자열은 한 글자씩 리스트에 추가되는 것이 append와 다르다.

l = [10, 20, 30]
l.extend('hello')


print(a)  # 출력: [1, 2, 3, 4, 5, 6]


..............................................
clear() 리스트의 모든 값을 지움
..............................................

insert() 주어진 위치에 값을 삽입하는 것이 append와 다름.

a.insert(2, 25)
print(a)  # 출력: [10, 20, 25, 30, 40] index순서:[0,1,2,3,4]


pop()은 insert()와 반대 개념. 주어진 위치에 값을 삭제함(값을 반환하고 삭제함)

a=[10, 20, 25, 30, 40] 

print(a.pop(2))  # 출력: 25
print(a)  # 출력: [10, 20, 30, 40]
..........................................

remove() 인덱스 0부터 찾기 시작해서 지정한 값을 제일 처음 발견한 인덱스의 값을 삭제함

반복문을 통해 지정한 값을 모두 지워줄수있다. 


l = [1, 2, 3, 1, 2, 2, 2, 1, 1]
while l.count(2):
    l.remove(2)


print(l)

[1, 3, 1, 1, 1]

다만 람다식의 사용을 더 권장함


l = [1, 2, 3, 1, 2, 2, 2, 1, 1]
list(filter(lambda x: x != 2, l))

........................................

reverse()
sort()

-> 지정한 리스트를 수정함

reversed()
sorted()

-> 특정 리스트를 참조하여 정렬,역정렬된 새 리스트를 생성
.........................................


튜플 tuple - 불변(상수인가)

튜플은 소괄호로 선언 a=()


튜플은 리스트에 비해 처리 속도가 조금 더 빠르기도 합니다. 그래서 단순히 데이터를 읽기만 할 때는 튜플을 사용하는 것이 더 효율적일 수 있습니다.

 튜플의 원소나 크기를 변경할 수 없다는 것입니다

3.2 불변성
튜플의 가장 큰 특징 중 하나는 불변성(immutable) 입니다. 이는 한 번 생성된 튜플의 내용(크기 및 원소)을 변경할 수 없다는 것을 의미합니다.

메모리 효율성: 튜플의 불변성 덕분에, 일반적으로 리스트보다 메모리 사용이 더 효율적입니다. 리스트는 원소의 추가나 삭제를 고려해 추가적인 메모리를 예약할 수 있습니다. 튜플은 그 크기가 고정되어 있으므로 추가적인 메모리 할당은 필요하지 않습니다.
해시 가능: 튜플의 불변성으로 인해 원소들이 모두 해시 가능할 경우 튜플도 해시 가능합니다. 즉, 튜플을 딕셔너리의 키로 사용할 수 있다는 것을 의미합니다.
보안: 데이터의 무결성을 유지해야 하는 경우나 데이터가 변경되어서는 안되는 경우에 튜플을 사용하면 좋습니다. 튜플의 불변성은 데이터 변경을 방지해 줍니다

..................

딕셔너리

딕셔너리 선언은 중괄호 a={key:value,key:value}


튜플의 리스트로서 하나의 딕셔너리를 구성할 수는 있지만 많이 사용하지는 않는다.

중첩된 딕셔너리는 특히 JSON 형식의 데이터를 다룰 때 자주 사용됩니다.
users = {
    "leehojun": {"city": "Jeju", "job": "Developer"},
    "licat": {"city": "Seoul", "job": "Designer"}
}

print(users["leehojun"]["job"]) 


users = {
key:{key:value,key:value...},
key:{key:value,key:value...}
}






zip()은 두 리스트를 서로 짝짓는 함수입니다. dict는 그 짝을 딕셔너리로 바꿔줍니다.

keys = ["name", "city", "job"]
values = ["licat", "Jeju", "Developer"]

new_dict = dict(zip(keys, values))
print(new_dict)





fromkeys( )

zip()과 비슷하지만 value값에 리스트를 선언하면 리스트 전체가 value가되서 zip()과는 다르다.


keys = ['name', 'city', 'job']
value = ['licat', 'Jeju', 'Developer']
print(dict.fromkeys(keys, value))

# 출력
{'name': ['licat', 'Jeju', 'Developer'],
'city': ['licat', 'Jeju', 'Developer'],
'job': ['licat', 'Jeju', 'Developer']}





get()

my_list.get('key', 'default(선택)')
# key값을 찾을건데, 없으면 default값에 들어간 값으로 알려줘 라는 뜻입니다.





items( )
딕셔너리의 키와 값을 쌍으로 추출하려면 items 메서드를 사용합니다. 반환되는 결과는 dict_items 객체입니다. 이 객체는 인덱싱이 안되니 인덱싱을 하고 싶다면 list로 변환 후 사용해주세요.


numbers = {'one': '하나', 'two': '둘', 'three': '셋'}
print('one' in numbers)
print('four' in numbers)

# 출력
True
False


popitem()
popitem 메서드는 딕셔너리의 마지막 키-값 쌍을 반환하고, 그 항목을 삭제합니다.




update( )

리스트끼리의 덧셈과 비슷함



numbers = {'one': '하나', 'two': '둘', 'three': '셋'}
numbers.update({'four': '넷', 'five': '다섯'})
print(numbers)



# 출력
{'one': '하나', 'two': '둘', 'three': '셋', 'four': '넷', 'five': '다섯'}

...................

셋(set)

맛만 보고 넘어가유


집합 

중괄호{}를 key:value로 구성하지 않고 선언하면 집합이됨

1.집합은 중복을 허용하지 않는다
2.집합은 순서가 없기 때문에 인덱싱으로 값을 얻을 수 없습니다. 

..................................

함수

함수 들여쓰기는 스페이스바 4번 입력


예시
def my_function(): #함수의 정의
    print('1') #함수의 본문 시작
    print('2') #함수의 본문 끝
print('3') #그냥 print('3')
my_function() #함수의 호출

출력
3
1
2



파라미터와 아규먼트는 구별되어야 하는 용어입니다. 보통 파선아실로 외웁니다. 파라미터는 선언할 때, 아규먼트는 실행할 때 사용되는 것을 얘기합니다.


```